
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C语言100题相关解题思路(部分) - Silence</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Soya,"> 
    <meta name="description" content="联系唯一邮箱：soya-kelaos@outlook.com,题目十一有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？该题的关键在于兔子的数量符合斐波那契数列-即第n位数等于n,"> 
    <meta name="author" content="Soya-Kelaos"> 
    <link rel="alternative" href="atom.xml" title="Silence" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">Silence</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="soya2.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">C语言100题相关解题思路(部分)</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">C语言100题相关解题思路(部分)</h1>
        <div class="stuff">
            <span>七月 22, 2019</span>
            

        </div>
        <div class="content markdown">
            <h3 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h3><p><strong>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</strong><br>该题的关键在于兔子的数量符合<strong>斐波那契数列</strong>-即第n位数等于n-1位和n-2位数相加。同样是通过相互赋值的方法改变相加数的位置。<br>例如1+1=2视为x+y=z，下一次计算应该为1+2=3，则相当于把y值当成新的x，把z看成新的y<br>即x+y=z<br>    x+y=z<br>相关代码</p>
<pre><code>printf(&quot;%d\n&quot;,y*2); &#x2F;&#x2F;打印出第一位数，乘二是因为一对兔子为两只
for(i=0;i&lt;30;i++)
{
    z=x+y;
    printf(&quot;%d\n&quot;,z*2); &#x2F;&#x2F;注意先打印后赋值
    x=y;
    y=z;
}</code></pre>

<h3 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h3><p><strong>判断101-200之间有多少个素数，并输出所有素数。</strong><br><strong>素数</strong>-指除了自身和1外，不能被其他数整除的数。主要是用两个for循环嵌套，首先循环查找的范围，然后循环查找的条件，查找条件比较简单，把被判断数从2除到201，每被整除就标记一次，不能被整除的就continue结束。除完之后查看标记的次数，根据素数的特性，凡是标记次数小于2的就输出概述，并另标记打印的次数(即说明找到了一个素数)。<br>相关代码</p>
<pre><code>int a=101,b,c,e=0;
for(;a&lt;201;a++)
{
    c=0; &#x2F;&#x2F;初始化整除标记为0；
    for(b=2;b &lt; a+1 ;b++) &#x2F;&#x2F;不检验被1整除，从2到a+1即可，若到a则测不到被自身整除
    {
        if(a%b==0) &#x2F;&#x2F;查找整除
            c++; &#x2F;&#x2F;每整除一次就标记+1
        else
            continue; &#x2F;&#x2F;不能被整除就结束循环
    }
    if(c&lt;2) &#x2F;&#x2F;当数只整除一次时进入
    {
        e++; &#x2F;&#x2F;素数标记+1
        printf(&quot;%d\n&quot;,a);
    }
}
printf(&quot;e=%d\n&quot;,e); &#x2F;&#x2F;素数标记打印要放在所有循环外面</code></pre>

<h3 id="题目二十六"><a href="#题目二十六" class="headerlink" title="题目二十六"></a>题目二十六</h3><p><strong>利用递归方法求5!</strong><br>利用函数嵌套的递归算法，主要理清楚递归次数和值的关系，阶乘的关系如下<br>   函数递归的最终返回值<br>                 ↑ 值120返回<br>         【f(4) ×5】<br>             ↑ 值24返回<br>     【f(3) ×4】<br>         ↑ 值6返回<br>  【f(2)×3】<br>      ↑ 值2返回<br>【f(1)×2】<br>f(0)时返回1给f(1)；然后依次返回<br>相关代码</p>
<pre><code>int fact(int x);&#x2F;&#x2F;使用函数前需要提前声明

int main()
{
    int a,b;
    scanf(&quot;%d&quot;,&amp;a);&#x2F;&#x2F;将程序升级成阶乘计算器，输入数a，并计算a的阶乘
    b=fact(a);
    printf(&quot;%d\n&quot;,b);
    return 0;
}

int fact(int x)&#x2F;&#x2F;函数定义
{
    int y;
    if(x&gt;0)
    {
        x--;&#x2F;&#x2F;需要在递归前先进行条件变换，不然会造成递归死循环
        y=fact(x)*(x+1);&#x2F;&#x2F;阶乘递归的关键，过程见上
        return y;&#x2F;&#x2F;最后返回的y值
    }
    return 1;&#x2F;&#x2F;x==0时返回1值
}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre>

<h3 id="题目四十一"><a href="#题目四十一" class="headerlink" title="题目四十一"></a>题目四十一</h3><p><strong>学习static定义静态变量的用法</strong><br>静态变量和普通的变量（即auto自动变量）的区别只有是否会自动释放内存。auto变量在函数调用结束的时候会自动释放，而static变量则不会释放，而是会一直存放在静态储存区，方便下次调用，适合类似求阶乘的算法，但这样的代价是内存得不到释放，同时降低了代码的可读性。<br>相关代码</p>
<pre><code>int main()
{
    int i;
    for(i=0;i&lt;3;i++)
        varer();
}

void varer()
{
    int var=0;
    static int static_var=0;
    printf(&quot;var=%d\n&quot;,var);
    printf(&quot;static_var=%d\n&quot;,static_var);
    var++;
    static_var++;
}</code></pre>
<p>程序执行后得到的值是<br>0 1<br>0 2<br>0 3<br>即auto变量var使用后释放，并再次赋值为0，而static_var不释放，一直自加到循环结束</p>
<h3 id="题目四十三"><a href="#题目四十三" class="headerlink" title="题目四十三"></a>题目四十三</h3><p><strong>学习使用static的另一用法。</strong><br>static变量和普通变量的另一区别就是储存的位置不同，内存供用户使用可分为三个部分<br>程序区、静态存储区和动态存储区。auto变量放在动态存储区，static变量放在静态存储区。<br>还有声明变量时不要放在同一层级即同一个花括号内<br>相关代码</p>
<pre><code>int i;
for(i=0;i&lt;3;i++)
{
    int num=2; &#x2F;&#x2F;auto变量在循环内外都可运行，在内每次都为2，在外则是递增
    printf(&quot;auto num=%d\n&quot;,num);
    num++;
    &#x2F;&#x2F;若取消花括号会因为变量名相同而报错
    {
        static int num=1;
        printf(&quot;static num=%d\n\n&quot;,num);
        num++;
    }
    &#x2F;&#x2F;从static变量声明起至花括号结束，所有相关语句均只与static变量有关
}</code></pre>
<p>相关代码2</p>
<pre><code>int var=0;
{
    var++; &#x2F;&#x2F;此时auto变量为1
    static int var=10;
    var++; &#x2F;&#x2F;static变量为11
    var++; &#x2F;&#x2F;static变量为12
    printf(&quot;-%d\n&quot;,var); &#x2F;&#x2F;打印static变量的var
    var++; &#x2F;&#x2F;static变量为13，但不会打印出来
}&#x2F;&#x2F;花括号结束，此时为auto变量
var++; &#x2F;&#x2F;auto变量为2
printf(&quot;%d\n&quot;,var);&#x2F;&#x2F;打印auto变量的var</code></pre>

<h3 id="题目六十六"><a href="#题目六十六" class="headerlink" title="题目六十六"></a>题目六十六</h3><p><strong>输入3个数a,b,c，按大小顺序输出，利用指针方法。</strong><br>运用指针分别指向a，b，c，然后像直接交换变量值一样交换指针地址就可以。<br>相关代码</p>
<pre><code>int main()
{
    int n1,n2,n3;
    scanf(&quot;%d,%d,%d&quot;,&amp;n1,&amp;n2,&amp;n3);
    int *p1,*p2,*p3;
    p1=&amp;n1; &#x2F;&#x2F;依次把变量地址赋值给指针，注意给指针赋值时变量要带地址符&amp;，指针不用带*号
    p2=&amp;n2;
    p3=&amp;n3;
    if(n1&gt;n2)
        trans(p1,p2);&#x2F;&#x2F;为了方便创建一个函数，此处的排序是由小到大
    if(n2&gt;n3)
        trans(p2,p3);
    if(n1&gt;n3)
        trans(p1,p3);
    printf(&quot;%d,%d,%d\n&quot;,n1,n2,n3);
    return 0;
}

void trans(int *p1,int *p2)
{
    int s;
    s=*p1; &#x2F;&#x2F;除声明的时侯，*p1指的都是该指针指向变量的值，例如此时\*p1指向n1，相当于s=n1
    *p1=*p2;
    *p2=s;
         &#x2F;&#x2F;若不加*号，即
    &#x2F;&#x2F;s=p1; 
    &#x2F;&#x2F;p1=p2; 
    &#x2F;&#x2F;p2=s;
    &#x2F;&#x2F;意味只交换了指针变量的值，即让p1指向n2，p2指向n1，这样子在打印n1、2、3时还是输入时的值
}</code></pre>

<h3 id="题目六十七"><a href="#题目六十七" class="headerlink" title="题目六十七"></a>题目六十七</h3><p><strong>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</strong><br>题目意为创建一个数组，由用户自己输入，输入完成后查看数组中的值，其中最大的值与第一个元素交换，最小的值与最后一个元素交换，其他元素保持不变。<br>要求利用指针来完成。输入与输出函数没有什么好说的。关键是交换元素的时机与方法。<br>首先要定义储存最大和最小的元素的指针，以及一个检查指针。<br>第一步就是循环检查，用数组的第一个元素检查到最后一个元素，元素指针先指向第一个元素，检查指针可跳过第一个，因为max=min=p没有检查的必要。检查完成后就是交换元素，此时找到了max元素、min元素，以及p指针指向最后一个元素。此时就和先前的方法一致声明一个临时变量count来交换数值。不要直接用指针p来临时存储变量。这里要注意的是，当max指针和p指针同时指向最后一个元素时(即最后一个值最大)，改变p的值的同时也改变了max原本的变量。所以还是另外声明比较保险。<br>相关代码</p>
<pre><code>void max_min(int array[])&#x2F;&#x2F;貌似函数返回值默认为int值时可不用声明(待检验)
{
    int *max,*min,*p;
    int count;
    max=min=array;
    for(p=array+1;p&lt;=array+5;p++)&#x2F;&#x2F;单独数组名代表该数组的首地址，+5则代表数组下标为5的元素
    {
        if(*p&gt;*max)
            max=p;
        else if(*p&lt;*min)
            min=p;
    }
    count=array[5];
    array[5]=*min;
    *min=count;
    if(max!=array+5&amp;&amp;min!=array)
    &#x2F;&#x2F;若数组是顺序的话，只交换头尾即可，所以检查max和min是否位于第一和最后一位
    {
        count=array[0];
        array[0]=*max;
        *max=count;
    }
}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre>

<h3 id="题目六十八"><a href="#题目六十八" class="headerlink" title="题目六十八"></a>题目六十八</h3><p><strong>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</strong><br>例如1，2，3，4，5；m=2，结果就是4，5，1，2，3；<br>主要思路还是和上题类似，要注意指针地址的变换。函数内只能用指针交换位置，具体见注释<br>相关代码</p>
<pre><code>int main()
{
    int a[5]={1,2,3,4,5};&#x2F;&#x2F;初始化数列
    Move(a,2);&#x2F;&#x2F;用函数来完成，设定移动两位，可更改
    for(int i=0;i&lt;5;i++)
        printf(&quot;%d\t&quot;,a[i]);
    printf(&quot;\n&quot;);
    return 0;
}

void Move(int a[],int m)
{
    int *R,*S,count;&#x2F;&#x2F;声明后指针和前指针以及临时变量
    for(int i=0;i &lt; m;i++)
    {
        R=a+4;&#x2F;&#x2F;将后指针放在数组的最后一项
        count=*R;&#x2F;&#x2F;同时将值赋给临时变量
        for(int j=4;j&gt;0;j--)&#x2F;&#x2F;每次移动数组内部必定移动四次，要从后往前循环
        {
            S=a+(j-1);&#x2F;&#x2F;前指针依次向前移动
            *R=*S;&#x2F;&#x2F;将前值赋给后值
            R=S;&#x2F;&#x2F;后指针往前移，此时与前指针指向同一值
        }
        *S=count;&#x2F;&#x2F;数组内交换完后把临时变量(即原最后值)赋给前指针，此时前指针指向第一值
    }
}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre>

<h3 id="题目七十六"><a href="#题目七十六" class="headerlink" title="题目七十六"></a>题目七十六</h3><p><strong>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函1/1+1/3+…+1/n(利用函数指针)</strong><br>这题的主要关键是练习利用函数指针，与指针函数不同，指针函数是指一个返回值为指针的函数，而函数指针意为一个指向函数的指针，相当于深层次点的函数嵌套。首先是检测输入数的奇偶性，然后不论该数是奇数还是偶数都执行一个参数是指针的函数，不过要注意的是与数学不同，C语言中先执行的是外部的函数。<br>相关代码</p>
<pre><code>int main()
{
    float peven(),podd(),dcall();
    float sum;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    if(n%2==0)
    {
        printf(&quot;even=&quot;);
        sum=dcall(peven,n);
        &#x2F;&#x2F;函数声明在下面，这里先执行的是dcall函数，然后再执行参数中指向Peven函数的指针，下同
    }
    else
    {
        printf(&quot;odd=&quot;);
        sum=dcall(podd,n);
    }
    printf(&quot;%f&quot;,sum);
}

float peven(int n)
{
    float s;
    int i;
    s=1;
    for(i=2;i&lt;=n;i+=2)
        s+=1&#x2F;(float)i;
    return(s);
}

float podd(int n)
{
    float s;
    int i;
    s=0;
    for(i=1;i&lt;=n;i+=2)
        s+=1&#x2F;(float)i;
    return(s);
}

float dcall(float (*fp)(),int n)
{
    float s;
    s=(*fp)(n);&#x2F;&#x2F;将指针指向的函数执行完后的返回值返回
    return(s);
}</code></pre>

<h3 id="题目一百"><a href="#题目一百" class="headerlink" title="题目一百"></a>题目一百</h3><p><strong>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，况原有的数据和计算出的平均分数存放在磁盘文件”stud”中。</strong><br>难度不大，注意输入数据存储到结构体中的时候，即使是用指针指向的数据(即P-&gt;num)的形式，也要加地址符&amp;，因为这里的num依然是变量，而不是地址。<br>例如数组名本身代表数组的首地址，形如声明为</p>
<pre><code>char a[10];
scanf(&quot;%c&quot;,a);&#x2F;&#x2F;合法
scanf(&quot;%c&quot;,&amp;a[0]);&#x2F;&#x2F;合法
scanf(&quot;%c&quot;,a[0]);&#x2F;&#x2F;不合法</code></pre>
<p>这里需要注意。<br>相关代码</p>
<pre><code>typedef struct S
{
    int num;
    char name[10];
    float scoreA;
    float scoreB;
    float scoreC;
    float scoreADV;
    struct S *NEXT;
}SUT;
&#x2F;&#x2F;此结构体前的typedef意为SUT等价于struct S
*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突
int main()
{
    SUT *HEAD,a,b,c,d,e,*P;
    P=HEAD=&amp;a;
    a.NEXT=&amp;b;
    b.NEXT=NULL;
    &#x2F;&#x2F;c.NEXT=&amp;d;  题目的要求为五个学生，但为了测试方便，故修改为两个
    &#x2F;&#x2F;d.NEXT=&amp;e;
    &#x2F;&#x2F;e.NEXT=NULL;
    while(P!=NULL)
    {
        printf(&quot;please input number and name of the student:\n&quot;);
        scanf(&quot;%d,%s&quot;,&amp;P-&gt;num,&amp;P-&gt;name);
        &#x2F;&#x2F;注意地址符，详细见上，此处还要注意%s要写在最后，这样避免把‘，’算成字符造成错误，下同
        printf(&quot;please input three score:\n&quot;);
        scanf(&quot;%f,%f,%f&quot;,&amp;P-&gt;scoreA,&amp;P-&gt;scoreB,&amp;P-&gt;scoreC);
        P-&gt;scoreADV=(P-&gt;scoreA+P-&gt;scoreB+P-&gt;scoreC)&#x2F;3;&#x2F;&#x2F;直接计算并存储平均成绩
        P=P-&gt;NEXT;
    }
    P=HEAD;
    FILE *F;
    F=fopen(&quot;student&quot;,&quot;w&quot;);
    while(P!=NULL)
    {
        fprintf(F,&quot;%d-%s\n&quot;,P-&gt;num,P-&gt;name);
        fprintf(F,&quot;A=%.2f,B=%.2f,C=%.2f,ADV=%.2f\n&quot;,P-&gt;scoreA,P-&gt;scoreB,P-&gt;scoreC,P-&gt;scoreADV);
        P=P-&gt;NEXT;
    }
    fclose(F);
    return 0;
}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre>

<h3 id="关于函数的实参和形参，以及指针作为参数时的情况"><a href="#关于函数的实参和形参，以及指针作为参数时的情况" class="headerlink" title="关于函数的实参和形参，以及指针作为参数时的情况"></a>关于函数的实参和形参，以及指针作为参数时的情况</h3><p>在声明一个函数时<br>例如：</p>
<pre><code>int Function(int a, int b);</code></pre>
<p>此时function函数中的a和b为形参</p>
<p>在主函数中</p>
<pre><code>int main()
{
    int Ra,Rb;
    Ra=1;
    Rb=2;
    Function(Ra,Rb);
    return 0;
}</code></pre>
<p>此时主函数中的Ra和Rb为实参<br>需要注意的是形参在函数中的运算不会影响实参的值</p>
<p>而指针作为参数的时候有点特殊，如果直接写成</p>
<pre><code>int Function(int *a, int b);</code></pre>
<p>主函数中</p>
<pre><code>int main()
{
    int *Ra;
    int Rb;
    Rb=2;
    Function(Ra,Rb);
    return 0;
}*&#x2F;&#x2F;无意义星号，在Markdown代表字符标签，与冲突程序语言冲突</code></pre>
<p>此时指针Ra同样不会因为函数中的指针a变化而变化。</p>
<blockquote><p>在初始化操作前，头指针参数head没有具体的地址值，在初始化操作前，头指针参数head才得到了具体的地址值，而这个地址值要返回给调用函数，所以，此时头指针参数head要设计成指针的指针类型。如果此时头指针参数head设计成指针类型，那么调用函数将无法得到在初始化函数中被赋值的头指针参数head的数值。</p>
<footer><strong>朱战立 数据结构—使用C语言</strong></footer></blockquote>

<p>总结就是作为参数形参不能影响实参，但是只要将指针的地址作为参数直接修改地址就可以影响主函数中指针参数的所指向的地址。</p>
<p>参考文档：<a href="https://www.jianshu.com/p/56d99a3049a5" target="_blank" rel="noopener">https://www.jianshu.com/p/56d99a3049a5</a><br>Sina博客原稿：<a href="http://blog.sina.com.cn/u/2292464751" target="_blank" rel="noopener">http://blog.sina.com.cn/u/2292464751</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
